"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServerHttpEnv = void 0;
const disposable_1 = require("@typed/disposable");
const objects_1 = require("@typed/objects");
const withHttpManagement_1 = require("./withHttpManagement");
const IS_HTTPS = /https/;
/**
 * Creates an Http Environment that works in browser and node.
 */
function createServerHttpEnv(options) {
    const env = { http: nodeHttpRequest };
    return options ? withHttpManagement_1.withHttpManagement(options, env) : env;
}
exports.createServerHttpEnv = createServerHttpEnv;
function nodeHttpRequest(url, options, callbacks) {
    const { success, failure } = callbacks;
    const { method = 'GET', headers, body } = options;
    const protocol = IS_HTTPS.test(url) ? 'https:' : 'http:';
    const http = protocol === 'https:' ? require('https') : require('http');
    const disposable = disposable_1.Disposable.lazy();
    const request = http.request(url, { method, headers: { 'Accept-Encoding': 'br,gzip,deflate', ...headers }, protocol }, (response) => {
        let responseText = '';
        let errored = false;
        switch (response.headers['content-encoding']) {
            case 'br':
                response = response.pipe(require('zlib').createBrotliDecompress());
                break;
            case 'gzip':
                response = response.pipe(require('zlib').createGunzip());
                break;
            case 'deflate':
                response = response.pipe(require('zlib').createInflate());
                break;
        }
        response.on('data', (chunk) => (responseText += chunk.toString()));
        response.on('error', (error) => {
            errored = true;
            disposable.addDisposable(failure(error));
        });
        response.on('end', () => {
            if (errored) {
                return;
            }
            const headersMap = {};
            for (const header in response.headers) {
                if (objects_1.hasOwnProperty(header, response.headers)) {
                    const value = response.headers[header];
                    headersMap[header] = Array.isArray(value) ? value.join(': ') : value;
                }
            }
            disposable.addDisposable(success({
                responseText,
                status: response.statusCode,
                statusText: response.statusMessage,
                headers: headersMap,
            }));
        });
    });
    if (body) {
        request.write(body);
    }
    request.end();
    disposable.addDisposable({ dispose: () => request.abort() });
    return disposable;
}
//# sourceMappingURL=createServerHttpEnv.js.map